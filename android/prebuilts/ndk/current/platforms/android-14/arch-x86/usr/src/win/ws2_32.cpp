/*
 * Copyright (C) 2014 Naver Corp. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "Ws2_32.h"

#if defined(WIN32)

extern "C" WSA2FunctionTable* functionTable()
{
    static WSA2FunctionTable table;
    return &table;
}

static HMODULE getModuleHandle(const char* moduleName)
{
    HMODULE module = GetModuleHandleA(moduleName);
    if (!module) {
        module = LoadLibraryA(moduleName);
        ASSERT(module);
    }
    return module;
}

static void* getProcAddress(const char* procName)
{
    return GetProcAddress(getModuleHandle("Ws2_32.dll"), procName);
}

static void* getWSA2FunctionAddress(const char* functionName, bool* success = 0)
{
    if (success && !*success)
        return 0;

    void* target = getProcAddress(functionName);
    if (target)
        return target;

    // A null address is still a failure case.
    if (!target && success)
        *success = false;

    return target;
}

#define ASSIGN_FUNCTION_TABLE_ENTRY(FunctionTypeName, FunctionName) \
    functionTable()->FunctionTypeName = reinterpret_cast<LPFN_##FunctionTypeName>(getWSA2FunctionAddress(#FunctionName))

bool initializeWSA2Shims()
{
    static bool success = true;
    static bool initialized = false;
    if (initialized)
        return success;

    initialized = true;
    ASSIGN_FUNCTION_TABLE_ENTRY(ACCEPT, accept);
    ASSIGN_FUNCTION_TABLE_ENTRY(BIND, bind);
    ASSIGN_FUNCTION_TABLE_ENTRY(CLOSESOCKET, closesocket);
    ASSIGN_FUNCTION_TABLE_ENTRY(CONNECT, connect);
    ASSIGN_FUNCTION_TABLE_ENTRY(IOCTLSOCKET, ioctlsocket);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETPEERNAME, getpeername);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETSOCKNAME, getsockname);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETSOCKOPT, getsockopt);
    ASSIGN_FUNCTION_TABLE_ENTRY(HTONL, htonl);
    ASSIGN_FUNCTION_TABLE_ENTRY(HTONS, htons);
    ASSIGN_FUNCTION_TABLE_ENTRY(INET_ADDR, inet_addr);
    ASSIGN_FUNCTION_TABLE_ENTRY(INET_NTOA, inet_ntoa);
    ASSIGN_FUNCTION_TABLE_ENTRY(LISTEN, listen);
    ASSIGN_FUNCTION_TABLE_ENTRY(NTOHL, ntohl);
    ASSIGN_FUNCTION_TABLE_ENTRY(NTOHS, ntohs);
    ASSIGN_FUNCTION_TABLE_ENTRY(RECV, recv);
    ASSIGN_FUNCTION_TABLE_ENTRY(RECVFROM, recvfrom);
    ASSIGN_FUNCTION_TABLE_ENTRY(SELECT, select);
    ASSIGN_FUNCTION_TABLE_ENTRY(SEND, send);
    ASSIGN_FUNCTION_TABLE_ENTRY(SENDTO, sendto);
    ASSIGN_FUNCTION_TABLE_ENTRY(SETSOCKOPT, setsockopt);
    ASSIGN_FUNCTION_TABLE_ENTRY(SHUTDOWN, shutdown);
    ASSIGN_FUNCTION_TABLE_ENTRY(SOCKET, socket);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETHOSTBYADDR, gethostbyaddr);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETHOSTBYNAME, gethostbyname);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETHOSTNAME, gethostname);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETHOSTNAMEW, GetHostNameW);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETSERVBYPORT, getservbyport);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETSERVBYNAME, getservbyname);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETPROTOBYNUMBER, getprotobynumber);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETPROTOBYNAME, getprotobyname);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASTARTUP, WSAStartup);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSACLEANUP, WSACleanup);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASETLASTERROR, WSASetLastError);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAGETLASTERROR, WSAGetLastError);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAISBLOCKING, WSAIsBlocking);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAUNHOOKBLOCKINGHOOK, WSAUnhookBlockingHook);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASETBLOCKINGHOOK, WSASetBlockingHook);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSACANCELBLOCKINGCALL, WSACancelBlockingCall);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAASYNCGETSERVBYNAME, WSAAsyncGetServByName);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAASYNCGETSERVBYPORT, WSAAsyncGetServByPort);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAASYNCGETPROTOBYNAME, WSAAsyncGetProtoByName);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAASYNCGETPROTOBYNUMBER, WSAAsyncGetProtoByNumber);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAASYNCGETHOSTBYNAME, WSAAsyncGetHostByName);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAASYNCGETHOSTBYADDR, WSAAsyncGetHostByAddr);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSACANCELASYNCREQUEST, WSACancelAsyncRequest);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAASYNCSELECT, WSAAsyncSelect);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAACCEPT, WSAAccept);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSACLOSEEVENT, WSACloseEvent);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSACONNECT, WSAConnect);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSACREATEEVENT, WSACreateEvent);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSADUPLICATESOCKETA, WSADuplicateSocketA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSADUPLICATESOCKETW, WSADuplicateSocketW);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAENUMNETWORKEVENTS, WSAEnumNetworkEvents);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAENUMPROTOCOLSA, WSAEnumProtocolsA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAENUMPROTOCOLSW, WSAEnumProtocolsW);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAEVENTSELECT, WSAEventSelect);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAGETOVERLAPPEDRESULT, WSAGetOverlappedResult);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAGETQOSBYNAME, WSAGetQOSByName);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAHTONL, WSAHtonl);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAHTONS, WSAHtons);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAIOCTL, WSAIoctl);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAJOINLEAF, WSAJoinLeaf);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSANTOHL, WSANtohl);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSANTOHS, WSANtohs);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSARECV, WSARecv);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSARECVDISCONNECT, WSARecvDisconnect);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSARECVFROM, WSARecvFrom);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSARESETEVENT, WSAResetEvent);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASEND, WSASend);
#if(_WIN32_WINNT >= 0x0600)
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASENDMSG, WSASendMsg);
#endif
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASENDDISCONNECT, WSASendDisconnect);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASENDTO, WSASendTo);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASETEVENT, WSASetEvent);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASOCKETA, WSASocketA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASOCKETW, WSASocketW);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAWAITFORMULTIPLEEVENTS, WSAWaitForMultipleEvents);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAADDRESSTOSTRINGA, WSAAddressToStringA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAADDRESSTOSTRINGW, WSAAddressToStringW);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASTRINGTOADDRESSA, WSAStringToAddressA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASTRINGTOADDRESSW, WSAStringToAddressW);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSALOOKUPSERVICEBEGINA, WSALookupServiceBeginA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSALOOKUPSERVICEBEGINW, WSALookupServiceBeginW);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSALOOKUPSERVICENEXTA, WSALookupServiceNextA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSALOOKUPSERVICENEXTW, WSALookupServiceNextW);
#if(_WIN32_WINNT >= 0x0501)
    ASSIGN_FUNCTION_TABLE_ENTRY(WSANSPIOCTL, WSANSPIoctl);
#endif
    ASSIGN_FUNCTION_TABLE_ENTRY(WSALOOKUPSERVICEEND, WSALookupServiceEnd);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAINSTALLSERVICECLASSA, WSAInstallServiceClassA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAINSTALLSERVICECLASSW, WSAInstallServiceClassW);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAREMOVESERVICECLASS, WSARemoveServiceClass);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAGETSERVICECLASSINFOA, WSAGetServiceClassInfoA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAGETSERVICECLASSINFOW, WSAGetServiceClassInfoW);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAENUMNAMESPACEPROVIDERSA, WSAEnumNameSpaceProvidersA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAENUMNAMESPACEPROVIDERSW, WSAEnumNameSpaceProvidersW);
#if(_WIN32_WINNT >= 0x0600)
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAENUMNAMESPACEPROVIDERSEXA, WSAEnumNameSpaceProvidersExA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAENUMNAMESPACEPROVIDERSEXW, WSAEnumNameSpaceProvidersExW);
#endif
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAGETSERVICECLASSNAMEBYCLASSIDA, WSAGetServiceClassNameByClassIdA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAGETSERVICECLASSNAMEBYCLASSIDW, WSAGetServiceClassNameByClassIdW);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASETSERVICEA, WSASetServiceA);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSASETSERVICEW, WSASetServiceW);
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAPROVIDERCONFIGCHANGE, WSAProviderConfigChange);
#if(_WIN32_WINNT >= 0x0600)
    ASSIGN_FUNCTION_TABLE_ENTRY(WSAPOLL, WSAPoll);
#endif
    ASSIGN_FUNCTION_TABLE_ENTRY(__WSAFDISSET, __WSAFDIsSet);
    ASSIGN_FUNCTION_TABLE_ENTRY(GETADDRINFO, getaddrinfo);
    ASSIGN_FUNCTION_TABLE_ENTRY(INET_PTONA, inet_pton);
    ASSIGN_FUNCTION_TABLE_ENTRY(INET_NTOPA, inet_ntop);

    if (!success)
        ::OutputDebugStringA("Could not initialize WinSock2 shims");
    return success;
}

extern "C" {

int     WinSock2WSAStartup(WORD wVersionRequested, _Out_ LPWSADATA lpWSAData)
{
    if (!initializeWSA2Shims()) {
        ASSERT(0);
        return SOCKET_ERROR;
    }

    return FORWARD_CALL(WSASTARTUP)(wVersionRequested, lpWSAData);
}


void    WinSock2WSASetLastError(int iError)
{
    FORWARD_CALL(WSASETLASTERROR)(iError);
}

int     WinSock2WSAIoctl(SOCKET s, DWORD dwIoControlCode, _In_reads_bytes_opt_(cbInBuffer) LPVOID lpvInBuffer, DWORD cbInBuffer,
    _Out_writes_bytes_to_opt_(cbOutBuffer, *lpcbBytesReturned) LPVOID lpvOutBuffer, DWORD cbOutBuffer, _Out_ LPDWORD lpcbBytesReturned,
    _Inout_opt_ LPWSAOVERLAPPED lpOverlapped, _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    return FORWARD_CALL(WSAIOCTL)(s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine);
}

}

#endif
